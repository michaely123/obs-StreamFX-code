// AUTOGENERATED COPYRIGHT HEADER START
// Copyright (C) 2023 Michael Fabian 'Xaymar' Dirks <info@xaymar.com>
// AUTOGENERATED COPYRIGHT HEADER END

#include "filter-spout-asyncvideo.hpp"
#include "strings.hpp"
#include "plugin.hpp"
#include "util/util-logging.hpp"

#include "warning-disable.hpp"
#include <algorithm>
#include <stdexcept>
#include "warning-enable.hpp"

// OBS
#include "warning-disable.hpp"
#include "warning-enable.hpp"

#ifdef _DEBUG
#define ST_PREFIX "<%s> "
#define D_LOG_ERROR(x, ...) P_LOG_ERROR(ST_PREFIX##x, __FUNCTION_SIG__, __VA_ARGS__)
#define D_LOG_WARNING(x, ...) P_LOG_WARN(ST_PREFIX##x, __FUNCTION_SIG__, __VA_ARGS__)
#define D_LOG_INFO(x, ...) P_LOG_INFO(ST_PREFIX##x, __FUNCTION_SIG__, __VA_ARGS__)
#define D_LOG_DEBUG(x, ...) P_LOG_DEBUG(ST_PREFIX##x, __FUNCTION_SIG__, __VA_ARGS__)
#else
#define ST_PREFIX "<filter::spout::asyncvideo> "
#define D_LOG_ERROR(...) P_LOG_ERROR(ST_PREFIX __VA_ARGS__)
#define D_LOG_WARNING(...) P_LOG_WARN(ST_PREFIX __VA_ARGS__)
#define D_LOG_INFO(...) P_LOG_INFO(ST_PREFIX __VA_ARGS__)
#define D_LOG_DEBUG(...) P_LOG_DEBUG(ST_PREFIX __VA_ARGS__)
#endif

#define ST_I18N "Filter.Spout.AsyncVideo"
#define ST_I18N_NAME ST_I18N ".Name"
#define ST_KEY_NAME "Name"

using namespace streamfx::filter::spout;

asyncvideo_instance::asyncvideo_instance(obs_data_t* data, obs_source_t* context) : obs::source_instance(data, context) {}

asyncvideo_instance::~asyncvideo_instance() {}

void asyncvideo_instance::load(obs_data_t* settings) {}

void asyncvideo_instance::migrate(obs_data_t* settings, uint64_t version) {}

void asyncvideo_instance::update(obs_data_t* settings) {}

struct obs_audio_data* asyncvideo_instance::filter_audio(struct obs_audio_data* audio) {
	return audio;
}

struct obs_source_frame* asyncvideo_instance::filter_video(struct obs_source_frame* frame) {
	return frame;
}

asyncvideo_factory::asyncvideo_factory()
{
	_info.id           = S_PREFIX "filter-spout-asyncvideo";
	_info.type         = OBS_SOURCE_TYPE_FILTER;
	_info.output_flags = OBS_SOURCE_ASYNC_VIDEO;

	support_size(false);
	finish_setup();
}

asyncvideo_factory::~asyncvideo_factory() {}

const char* asyncvideo_factory::get_name()
{
	return D_TRANSLATE(ST_I18N);
}

void asyncvideo_factory::get_defaults2(obs_data_t* settings)
{
	obs_data_set_default_string(settings, ST_KEY_NAME, "${SOURCE}/${FILTER}");
}

obs_properties_t* asyncvideo_factory::get_properties2(asyncvideo_instance* data)
{
	obs_properties_t* pr = obs_properties_create();

	{
		auto p = obs_properties_add_text(pr, ST_KEY_NAME, D_TRANSLATE(ST_I18N_NAME), obs_text_type::OBS_TEXT_DEFAULT);
	}

	return pr;
}

std::shared_ptr<asyncvideo_factory> asyncvideo_factory::instance()
{
	static std::weak_ptr<asyncvideo_factory> winst;
	static std::mutex                        mtx;

	std::unique_lock<decltype(mtx)> lock(mtx);
	auto                            instance = winst.lock();
	if (!instance) {
		instance = std::shared_ptr<asyncvideo_factory>(new asyncvideo_factory());
		winst    = instance;
	}
	return instance;
}

static std::shared_ptr<asyncvideo_factory> loader_instance;

static auto loader = streamfx::loader(
	[]() { // Initalizer
		loader_instance = asyncvideo_factory::instance();
	},
	[]() { // Finalizer
		loader_instance.reset();
	},
	streamfx::loader_priority::NORMAL);
