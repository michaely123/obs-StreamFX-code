// AUTOGENERATED COPYRIGHT HEADER START
// Copyright (C) 2017-2024 Michael Fabian 'Xaymar' Dirks <info@xaymar.com>
// Copyright (C) 2022 lainon <GermanAizek@yandex.ru>
// AUTOGENERATED COPYRIGHT HEADER END

#include "gs-texrender.hpp"
#include "obs/gs/gs-helper.hpp"

#include "warning-disable.hpp"
#include <stdexcept>
#include "warning-enable.hpp"

streamfx::obs::gs::texrender::~texrender()
{
	auto gctx = streamfx::obs::gs::context();
	gs_texrender_destroy(_ptr);
}

streamfx::obs::gs::texrender::texrender(gs_color_format colorFormat, gs_zstencil_format zsFormat) : _color_format(colorFormat), _zstencil_format(zsFormat)
{
#ifdef _DEBUG
	_active = false;
#endif
	auto gctx = streamfx::obs::gs::context();
	if (_ptr = gs_texrender_create(colorFormat, zsFormat); !_ptr) {
		throw std::runtime_error("Failed to create render target.");
	}
}

streamfx::obs::gs::texrender::op::op(std::shared_ptr<streamfx::obs::gs::texrender> rt, uint32_t width, uint32_t height, gs_color_space cs) : parent(rt)
{
#ifdef _DEBUG
	if (parent == nullptr)
		throw std::invalid_argument("rt");
	if (parent->_active)
		throw std::logic_error("Can't start rendering to the same render target twice.");
#endif

	auto gctx = streamfx::obs::gs::context();
	gs_texrender_reset(parent->_ptr);
	if (!gs_texrender_begin_with_color_space(parent->_ptr, width, height, cs)) {
		throw std::runtime_error("Failed to begin rendering to render target.");
	}

#ifdef _DEBUG
	parent->_active = true;
#endif
}

streamfx::obs::gs::texrender::op::~op()
{
#ifdef _DEBUG
	if (parent == nullptr)
		return;
#endif

	auto gctx = streamfx::obs::gs::context();
	gs_texrender_end(parent->_ptr);

#ifdef _DEBUG
	parent->_active = false;
#endif
}

static std::shared_ptr<streamfx::obs::gs::texrender::pool> loader_instance;

static auto loader = streamfx::loader(
	[]() { // Initializer
		loader_instance = streamfx::obs::gs::texrender::pool::instance();
	},
	[]() { // Finalizer
		loader_instance.reset();
	},
	streamfx::loader_priority::HIGH);
