// AUTOGENERATED COPYRIGHT HEADER START
// Copyright (C) 2017-2023 Michael Fabian 'Xaymar' Dirks <info@xaymar.com>
// Copyright (C) 2022 lainon <GermanAizek@yandex.ru>
// AUTOGENERATED COPYRIGHT HEADER END

#pragma once
#include "common.hpp"
#include "gs-texture.hpp"
#include "util/util-pool.hpp"

#include "warning-disable.hpp"
#include <memory>
#include "warning-enable.hpp"

namespace streamfx::obs::gs {
	class texrender : public std::enable_shared_from_this<streamfx::obs::gs::texrender> {
		protected:
#ifdef _DEBUG
		bool _active;
#endif
		gs_texrender_t*    _ptr;
		gs_color_format    _color_format;
		gs_zstencil_format _zstencil_format;

		public:
		class op;
		friend op;

		public:
		~texrender();

		/** Create a new texrender with a given format.
		 * 
		 */
		texrender(gs_color_format format, gs_zstencil_format zstencil_format);

		FORCE_INLINE gs_color_format color_format() const
		{
			return _color_format;
		}

		FORCE_INLINE gs_zstencil_format zstencil_format() const
		{
			return _zstencil_format;
		}

		/** Try and reset the underlying texrender object.
		 *
		 */
		FORCE_INLINE void reset()
		{
			gs_texrender_reset(_ptr); // Does not require a graphic context.
			// TODO: Actually clear the included texture, so that the driver knows it's not needed anymore.
			// Might be significantly more difficult than expected.
		}

		/** Render into the texrender.
		 *
		 */
		FORCE_INLINE std::shared_ptr<streamfx::obs::gs::texrender::op> render(uint32_t width, uint32_t height, gs_color_space cs = GS_CS_SRGB)
		{
			return std::make_shared<streamfx::obs::gs::texrender::op>(this->shared_from_this(), width, height, cs);
		}

		FORCE_INLINE operator gs_texrender_t*() const
		{
			return _ptr;
		}

		[[deprecated("Use typecasts instead.")]] gs_texture_t* get_object()
		{
			return *this;
		}

		[[deprecated("Unsafe! Contained texture only lives as long as texrender object.")]] std::shared_ptr<streamfx::obs::gs::texture> get_texture()
		{
			return std::make_shared<streamfx::obs::gs::texture>(*this, false);
		}

		[[deprecated("Unsafe! Contained texture only lives as long as texrender object.")]] void get_texture(streamfx::obs::gs::texture& tex)
		{
			tex = streamfx::obs::gs::texture(*this, false);
		}

		[[deprecated("Unsafe! Contained texture only lives as long as texrender object.")]] void get_texture(std::shared_ptr<streamfx::obs::gs::texture>& tex)
		{
			tex = std::make_shared<streamfx::obs::gs::texture>(*this, false);
		}

		[[deprecated("Unsafe! Contained texture only lives as long as texrender object.")]] void get_texture(std::unique_ptr<streamfx::obs::gs::texture>& tex)
		{
			tex = std::make_unique<streamfx::obs::gs::texture>(*this, false);
		}

		FORCE_INLINE operator gs_texture_t*() const
		{
			return gs_texrender_get_texture(_ptr);
		}

		class op {
			std::shared_ptr<streamfx::obs::gs::texrender> parent;

			public:
			~op();

			op(std::shared_ptr<streamfx::obs::gs::texrender> rt, uint32_t width, uint32_t height, gs_color_space cs = GS_CS_SRGB);

			// Move Constructor
			FORCE_INLINE op(streamfx::obs::gs::texrender::op&& r) noexcept
			{
				this->parent = r.parent;
				r.parent     = nullptr;
			}

			// Move Operator
			op& operator=(const streamfx::obs::gs::texrender::op&&) = delete;

			// Copy Constructor
			op(const streamfx::obs::gs::texrender::op&) = delete;

			// Copy Operator
			op& operator=(const streamfx::obs::gs::texrender::op& r) = delete;
		};

		public:
		class pool;
		typedef streamfx::util::pool<streamfx::obs::gs::texrender::pool, streamfx::obs::gs::texrender, 1000> _pool_t;

		class pool : public _pool_t {
			friend streamfx::util::singleton<streamfx::obs::gs::texrender::pool>;
			friend _pool_t;

			public:
			virtual ~pool() {}

			protected:
			pool() : _pool_t() {}

			virtual void reset(void* ptr)
			{
				reinterpret_cast<streamfx::obs::gs::texrender*>(ptr)->reset();
			}
		};
	};

} // namespace streamfx::obs::gs
