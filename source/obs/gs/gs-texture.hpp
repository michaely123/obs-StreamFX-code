// AUTOGENERATED COPYRIGHT HEADER START
// Copyright (C) 2017-2023 Michael Fabian 'Xaymar' Dirks <info@xaymar.com>
// AUTOGENERATED COPYRIGHT HEADER END

#pragma once
#include "common.hpp"
#include "obs/gs/gs-helper.hpp"
#include "util/util-pool.hpp"

#include "warning-disable.hpp"
#include <filesystem>
#include <memory>
#include "warning-enable.hpp"

namespace streamfx::obs::gs {
	enum class texture_flags : uint8_t {
		None,
		Dynamic      = 1 << 0,
		BuildMipMaps = 1 << 1,
		Shared       = 1 << 2,
		GlobalShared = 1 << 3,
	};

	class texture {
		public:
		protected:
		bool                  _is_owner;
		gs_texture_t*         _texture;
		texture_flags         _flags;
		std::filesystem::path _file;

		public:
		~texture();

		/*!
		 * \brief Create a 2D Texture
		 *
		 * \param width Width of the 2D Texture
		 * \param height Height of the 2D Texture
		 * \param format Color Format to use
		 * \param mip_levels Number of Mip Levels available
		 * \param data Texture data including mipmaps
		 * \param flags Texture Flags
		 */
		texture(uint32_t width, uint32_t height, gs_color_format format, uint32_t mip_levels, const uint8_t** data, texture_flags flags);

		/*!
		* \brief Load a texture from a file
		*
		* Creates a new #GS::Texture from a file located on disk. If the
		* file can not be found, accessed or read, a #Plugin::file_not_found_error
		* will be thrown. If there is an error reading the file, a
		* #Plugin::io_error will be thrown.
		*
		* \param file File to create the texture from.
		*/
		texture(std::filesystem::path file);

		/*!
		* \brief Create a texture from an existing gs_texture_t object.
		*/
		texture(gs_texture_t* tex, bool takeOwnership = false)
		{
			_is_owner = takeOwnership;
			_texture  = tex;
			_flags    = texture_flags::None;
			_file     = std::filesystem::path();
		}

		[[deprecated("Use typecast instead.")]] gs_texture_t* get_object()
		{
			return _texture;
		}

		/** Width of the contained texture.
		 * 
		 */
		FORCE_INLINE uint32_t width() const
		{
			return gs_texture_get_width(_texture);
		}

		/** Height of the contained texture.
		 * 
		 */
		FORCE_INLINE uint32_t height() const
		{
			return gs_texture_get_height(_texture);
		}

		/** Format of the texture.
		 * 
		 */
		FORCE_INLINE gs_color_format color_format() const
		{
			return gs_texture_get_color_format(_texture);
		}

		/** Flags used for the texture
		 * 
		 */
		FORCE_INLINE texture_flags flags() const
		{
			return _flags;
		}

		/** The file from which this texture originates from.
		 *
		 * Will be an empty string if not created from a file.
		 */
		FORCE_INLINE std::filesystem::path file() const
		{
			return _file;
		}

		/** Load the texture into a texture unit slot.
		 * 
		 */
		FORCE_INLINE void load(int32_t unit)
		{
			auto gctx = streamfx::obs::gs::context();
			gs_load_texture(_texture, unit);
		}

		FORCE_INLINE operator gs_texture_t*() const
		{
			return _texture;
		}

		public:
		class pool;
		typedef std::tuple<uint64_t, std::filesystem::path>                                                                _pool_key_t;
		typedef streamfx::util::multipool<streamfx::obs::gs::texture::pool, streamfx::obs::gs::texture, 1000, _pool_key_t> _pool_t;

		class pool : public _pool_t {
			friend streamfx::util::singleton<streamfx::obs::gs::texture::pool>;
			friend _pool_t;

			public:
			virtual ~pool() {}

			protected:
			pool() : _pool_t() {}

			static _pool_key_t as_key(streamfx::obs::gs::texture* ptr)
			{
				if (auto file = ptr->file(); !file.empty()) {
					return _pool_key_t{0, file};
				} else {
					uint64_t left = (uint64_t(ptr->width()) << 48) | (uint64_t(ptr->height()) << 32) | (uint64_t(ptr->color_format()) << 16) | (uint64_t(ptr->flags()) << 0);
					return _pool_key_t{left, std::string()};
				}
			}

			static _pool_key_t as_key(uint32_t width, uint32_t height, gs_color_format format, uint32_t mip_levels, const uint8_t**, texture_flags flags)
			{
				uint64_t left = (uint64_t(width) << 48) | (uint64_t(height) << 32) | (uint64_t(format) << 16) | (uint64_t(flags) << 0);
				return _pool_key_t{left, std::string()};
			}

			static _pool_key_t as_key(std::string file)
			{
				return _pool_key_t{0, file};
			}

			virtual void reset(void* ptr) {}
		};
	};
} // namespace streamfx::obs::gs

P_ENABLE_BITMASK_OPERATORS(streamfx::obs::gs::texture_flags)
